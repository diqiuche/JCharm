/**
 * Copyright (c) 2016, Wang Wei (JCharm@aliyun.com) All rights reserved.
 */
package io.github.jcharm.source;

import java.io.Serializable;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.BiConsumer;
import java.util.function.Function;

import io.github.jcharm.common.ConstructCreator;
import io.github.jcharm.common.FieldAttribute;
import io.github.jcharm.source.annotation.EntityAutoGenerated;
import io.github.jcharm.source.annotation.EntityCacheable;
import io.github.jcharm.source.annotation.EntityColumn;
import io.github.jcharm.source.annotation.EntityDistributeGenerator;
import io.github.jcharm.source.annotation.EntityDistributeTables;
import io.github.jcharm.source.annotation.EntityId;
import io.github.jcharm.source.annotation.EntityTable;
import io.github.jcharm.source.annotation.EntityTransient;
import io.github.jcharm.source.annotation.EntityVirtual;

/**
 * Entity类的相关信息类.
 *
 * @param <T> Entity类泛型
 */
public final class EntityInfo<T> {

	private static final ConcurrentHashMap<Class, EntityInfo> entityInfos = new ConcurrentHashMap<>();

	// Entity类的类名
	private final Class<T> type;

	// 类对应的数据表名, 如果是VirtualEntity 类, 则该字段为null
	private final String table;

	private final ConstructCreator<T> creator;

	/** 主键. */
	final FieldAttribute<T, Serializable> primary;

	private final EntityCache<T> cache;

	// key是field的name, 不是sql字段, 存放所有与数据库对应的字段, 包括主键
	private final HashMap<String, FieldAttribute<T, Serializable>> attributeMap = new HashMap<>();

	/** FieldAttribute. */
	final FieldAttribute<T, Serializable>[] attributes;

	// key是field的name, value是Column的别名, 即数据库表的字段名, 只有field.name与Column.name不同才存放在aliasmap里.
	private final Map<String, String> aliasmap;

	private final Map<String, FieldAttribute<T, Serializable>> updateAttributeMap = new HashMap<>();

	/** 用于反向LIKE使用. */
	final String containSQL;

	/** 用于反向LIKE使用. */
	final String notcontainSQL;

	/** The query sql. */
	final String querySQL;

	/** 数据库中所有字段. */
	final FieldAttribute<T, Serializable>[] queryAttributes;

	/** The insert sql. */
	final String insertSQL;

	/** 数据库中所有可新增字段. */
	final FieldAttribute<T, Serializable>[] insertAttributes;

	/** The update sql. */
	final String updateSQL;

	/** 数据库中所有可更新字段. */
	final FieldAttribute<T, Serializable>[] updateAttributes;

	/** The delete sql. */
	final String deleteSQL;

	private final Map<String, String> sortOrderbySqls = new ConcurrentHashMap<>();

	private final int nodeid;

	/** The distribute tables. */
	final Class[] distributeTables;

	/** The auto generated. */
	final boolean autoGenerated;

	/** The distributed. */
	final boolean distributed;

	/** The inited primary value. */
	boolean initedPrimaryValue = false;

	/** The primary value. */
	final AtomicLong primaryValue = new AtomicLong(0);

	/** The allocation size. */
	final int allocationSize;

	/** The fullloader. */
	final Function<Class, List> fullloader;

	/**
	 * 加载获取EntityInfo.
	 *
	 * @param <T> Entity类泛型
	 * @param clazz Entity类
	 * @param nodeid int
	 * @param cacheForbidden boolean
	 * @param conf Properties
	 * @param fullloader Function
	 * @return EntityInfo
	 */
	public static <T> EntityInfo<T> load(final Class<T> clazz, final int nodeid, final boolean cacheForbidden, final Properties conf, final Function<Class, List> fullloader) {
		EntityInfo rs = EntityInfo.entityInfos.get(clazz);
		if (rs != null) {
			return rs;
		}
		synchronized (EntityInfo.entityInfos) {
			rs = EntityInfo.entityInfos.get(clazz);
			if (rs == null) {
				if (nodeid < 0) {
					throw new IllegalArgumentException("nodeid(" + nodeid + ") is illegal");
				}
				rs = new EntityInfo(clazz, nodeid, cacheForbidden, conf, fullloader);
				EntityInfo.entityInfos.put(clazz, rs);
				if (rs.cache != null) {
					if (fullloader == null) {
						throw new IllegalArgumentException(clazz.getName() + " auto loader  is illegal");
					}
					rs.cache.fullLoad();
				}
			}
			return rs;
		}
	}

	/**
	 * 获取Entity类信息.
	 *
	 * @param <T> Entity类泛型
	 * @param clazz Entity类
	 * @return EntityInfo
	 */
	static <T> EntityInfo<T> get(final Class<T> clazz) {
		return EntityInfo.entityInfos.get(clazz);
	}

	private EntityInfo(final Class<T> type, final int nodeid, final boolean cacheForbidden, Properties conf, final Function<Class, List> fullloader) {
		this.type = type;
		this.fullloader = fullloader;
		this.nodeid = nodeid >= 0 ? nodeid : 0;
		final EntityDistributeTables dt = type.getAnnotation(EntityDistributeTables.class);
		this.distributeTables = dt == null ? null : dt.value();
		final EntityTable t = type.getAnnotation(EntityTable.class);
		if (type.getAnnotation(EntityVirtual.class) != null) {
			this.table = null;
		} else {
			this.table = (t == null) ? type.getSimpleName().toLowerCase() : (t.catalog().isEmpty()) ? t.name() : (t.catalog() + '.' + t.name());
		}
		this.creator = ConstructCreator.create(type);
		FieldAttribute idAttr0 = null;
		Map<String, String> aliasmap0 = null;
		Class cltmp = type;
		final Set<String> fields = new HashSet<>();
		final List<FieldAttribute<T, Serializable>> queryattrs = new ArrayList<>();
		final List<String> insertcols = new ArrayList<>();
		final List<FieldAttribute<T, Serializable>> insertattrs = new ArrayList<>();
		final List<String> updatecols = new ArrayList<>();
		final List<FieldAttribute<T, Serializable>> updateattrs = new ArrayList<>();
		boolean auto = false;
		boolean sqldistribute = false;
		int allocationSize0 = 0;
		do {
			for (final Field field : cltmp.getDeclaredFields()) {
				if (Modifier.isStatic(field.getModifiers())) {
					continue;
				}
				if (Modifier.isFinal(field.getModifiers())) {
					continue;
				}
				if (field.getAnnotation(EntityTransient.class) != null) {
					continue;
				}
				if (fields.contains(field.getName())) {
					continue;
				}
				final String fieldname = field.getName();
				final EntityColumn col = field.getAnnotation(EntityColumn.class);
				final String sqlfield = (col == null) || col.name().isEmpty() ? fieldname : col.name();
				if (!fieldname.equals(sqlfield)) {
					if (aliasmap0 == null) {
						aliasmap0 = new HashMap<>();
					}
					aliasmap0.put(fieldname, sqlfield);
				}
				FieldAttribute attr;
				try {
					attr = FieldAttribute.create(cltmp, field);
				} catch (final RuntimeException e) {
					continue;
				}
				if ((field.getAnnotation(EntityId.class) != null) && (idAttr0 == null)) {
					idAttr0 = attr;
					final EntityAutoGenerated gv = field.getAnnotation(EntityAutoGenerated.class);
					auto = gv != null;
					final EntityDistributeGenerator dg = field.getAnnotation(EntityDistributeGenerator.class);
					if (dg != null) {
						if (!field.getType().isPrimitive()) {
							throw new RuntimeException(cltmp.getName() + "'s @" + EntityDistributeGenerator.class.getSimpleName() + " primary must be primitive class type field");
						}
						sqldistribute = true;
						auto = false;
						allocationSize0 = dg.allocationSize();
						this.primaryValue.set(dg.initialValue());
					}
					if (!auto) {
						insertcols.add(sqlfield);
						insertattrs.add(attr);
					}
				} else {
					if ((col == null) || col.insertable()) {
						insertcols.add(sqlfield);
						insertattrs.add(attr);
					}
					if ((col == null) || col.updatable()) {
						updatecols.add(sqlfield);
						updateattrs.add(attr);
						this.updateAttributeMap.put(fieldname, attr);
					}
				}
				queryattrs.add(attr);
				fields.add(fieldname);
				this.attributeMap.put(fieldname, attr);
			}
		} while ((cltmp = cltmp.getSuperclass()) != Object.class);
		this.primary = idAttr0;
		this.aliasmap = aliasmap0;
		this.attributes = this.attributeMap.values().toArray(new FieldAttribute[this.attributeMap.size()]);
		this.queryAttributes = queryattrs.toArray(new FieldAttribute[queryattrs.size()]);
		this.insertAttributes = insertattrs.toArray(new FieldAttribute[insertattrs.size()]);
		this.updateAttributes = updateattrs.toArray(new FieldAttribute[updateattrs.size()]);
		if (this.table != null) {
			final StringBuilder insertsb = new StringBuilder();
			final StringBuilder insertsb2 = new StringBuilder();
			for (final String col : insertcols) {
				if (insertsb.length() > 0) {
					insertsb.append(',');
				}
				insertsb.append(col);
				if (insertsb2.length() > 0) {
					insertsb2.append(',');
				}
				insertsb2.append('?');
			}
			this.insertSQL = "INSERT INTO " + this.table + "(" + insertsb + ") VALUES(" + insertsb2 + ")";
			final StringBuilder updatesb = new StringBuilder();
			for (final String col : updatecols) {
				if (updatesb.length() > 0) {
					updatesb.append(", ");
				}
				updatesb.append(col).append(" = ?");
			}
			this.updateSQL = "UPDATE " + this.table + " SET " + updatesb + " WHERE " + this.getPrimarySQLColumn(null) + " = ?";
			this.deleteSQL = "DELETE FROM " + this.table + " WHERE " + this.getPrimarySQLColumn(null) + " = ?";
			this.querySQL = "SELECT * FROM " + this.table + " WHERE " + this.getPrimarySQLColumn(null) + " = ?";
		} else {
			this.insertSQL = null;
			this.updateSQL = null;
			this.deleteSQL = null;
			this.querySQL = null;
		}
		this.autoGenerated = auto;
		this.distributed = sqldistribute;
		this.allocationSize = allocationSize0;
		final EntityCacheable c = type.getAnnotation(EntityCacheable.class);
		if ((this.table == null) || (!cacheForbidden && (c != null))) {
			this.cache = new EntityCache(this);
		} else {
			this.cache = null;
		}
		if (conf == null) {
			conf = new Properties();
		}
		this.containSQL = conf.getProperty(DataDefaultSource.JDBC_CONTAIN_SQLTEMPLATE, "LOCATE(${keystr}, ${column}) > 0");
		this.notcontainSQL = conf.getProperty(DataDefaultSource.JDBC_NOTCONTAIN_SQLTEMPLATE, "LOCATE(${keystr}, ${column}) = 0");
	}

	/**
	 * 生成Entity对象主键值.
	 *
	 * @param src Entity对象
	 */
	public void createPrimaryValue(final T src) {
		final long v = this.allocationSize > 1 ? ((this.primaryValue.incrementAndGet() * this.allocationSize) + this.nodeid) : this.primaryValue.incrementAndGet();
		if ((this.primary.getFieldType() == int.class) || (this.primary.getFieldType() == Integer.class)) {
			this.getPrimary().setFieldValue(src, ((Long) v).intValue());
		} else {
			this.getPrimary().setFieldValue(src, v);
		}
	}

	/**
	 * 获取EntityCache.
	 *
	 * @return EntityCache
	 */
	public EntityCache<T> getCache() {
		return this.cache;
	}

	/**
	 * 判断缓存是否完全加载.
	 *
	 * @return boolean
	 */
	public boolean isCacheFullLoaded() {
		return (this.cache != null) && this.cache.isFullLoaded();
	}

	/**
	 * 获取ConstructCreator对象.
	 *
	 * @return ConstructCreator
	 */
	public ConstructCreator<T> getCreator() {
		return this.creator;
	}

	/**
	 * 获取Entity类Class.
	 *
	 * @return Class
	 */
	public Class<T> getType() {
		return this.type;
	}

	/**
	 * 判断是否为虚拟Entity类.
	 *
	 * @return boolean
	 */
	public boolean isVirtualEntity() {
		return this.table == null;
	}

	/**
	 * 获取Entity类的数据库表名称.
	 *
	 * @return the table
	 */
	public String getTable() {
		return this.table;
	}

	/**
	 * 获取主键的FieldAttribute.
	 *
	 * @return FieldAttribute
	 */
	public FieldAttribute<T, Serializable> getPrimary() {
		return this.primary;
	}

	/**
	 * 遍历FieldAttribute集合.
	 *
	 * @param action BiConsumer
	 */
	public void forEachAttribute(final BiConsumer<String, FieldAttribute<T, Serializable>> action) {
		this.attributeMap.forEach(action);
	}

	/**
	 * 根据字段名获取FieldAttribute.
	 *
	 * @param fieldname String
	 * @return FieldAttribute
	 */
	public FieldAttribute<T, Serializable> getAttribute(final String fieldname) {
		if (fieldname == null) {
			return null;
		}
		return this.attributeMap.get(fieldname);
	}

	/**
	 * 根据字段名更新FieldAttribute.
	 *
	 * @param fieldname String
	 * @return FieldAttribute
	 */
	public FieldAttribute<T, Serializable> getUpdateAttribute(final String fieldname) {
		return this.updateAttributeMap.get(fieldname);
	}

	/**
	 * 判断Entity类是否使用别名.
	 *
	 * @return boolean
	 */
	public boolean isNoAlias() {
		return this.aliasmap == null;
	}

	/**
	 * 根据PageTurn生成orderby子句.
	 *
	 * @param pageTurn PageTurn
	 * @return String
	 */
	protected String createSQLOrderby(final PageTurn pageTurn) {
		if ((pageTurn == null) || (pageTurn.getSort() == null) || pageTurn.getSort().isEmpty() || (pageTurn.getSort().indexOf(';') >= 0) || (pageTurn.getSort().indexOf('\n') >= 0)) {
			return "";
		}
		final String sort = pageTurn.getSort();
		String sql = this.sortOrderbySqls.get(sort);
		if (sql != null) {
			return sql;
		}
		final StringBuilder sb = new StringBuilder();
		sb.append(" ORDER BY ");
		if (this.isNoAlias()) {
			sb.append(sort);
		} else {
			boolean flag = false;
			for (final String item : sort.split(",")) {
				if (item.isEmpty()) {
					continue;
				}
				final String[] sub = item.split("\\s+");
				if (flag) {
					sb.append(',');
				}
				if ((sub.length < 2) || sub[1].equalsIgnoreCase("ASC")) {
					sb.append(this.getSQLColumn("a", sub[0])).append(" ASC");
				} else {
					sb.append(this.getSQLColumn("a", sub[0])).append(" DESC");
				}
				flag = true;
			}
		}
		sql = sb.toString();
		this.sortOrderbySqls.put(sort, sql);
		return sql;
	}

	/**
	 * 根据表别名和字段名称获取其对应列名.
	 *
	 * @param tabalis String
	 * @param fieldname String
	 * @return String
	 */
	public String getSQLColumn(final String tabalis, final String fieldname) {
		return this.aliasmap == null ? (tabalis == null ? fieldname : (tabalis + '.' + fieldname)) : (tabalis == null ? this.aliasmap.getOrDefault(fieldname, fieldname) : (tabalis + '.' + this.aliasmap.getOrDefault(fieldname, fieldname)));
	}

	/**
	 * 获取主键列名.
	 *
	 * @return String
	 */
	public String getPrimarySQLColumn() {
		return this.getSQLColumn(null, this.primary.getFieldDefaultName());
	}

	/**
	 * 获取数据库表字段.
	 *
	 * @param tabalis String
	 * @return String
	 */
	public String getPrimarySQLColumn(final String tabalis) {
		return this.getSQLColumn(tabalis, this.primary.getFieldDefaultName());
	}

	/**
	 * 获取Entity类字段FieldAttribute Map.
	 *
	 * @return Map
	 */
	protected Map<String, FieldAttribute<T, Serializable>> getAttributes() {
		return this.attributeMap;
	}

	/**
	 * 获取数据库结果集.
	 *
	 * @param sels SelectColumn
	 * @param set ResultSet
	 * @return T
	 * @throws SQLException SQL异常
	 */
	protected T getValue(final SelectColumn sels, final ResultSet set) throws SQLException {
		final T obj = this.creator.construct();
		for (final FieldAttribute<T, Serializable> attr : this.queryAttributes) {
			if ((sels == null) || sels.test(attr.getFieldDefaultName())) {
				Serializable o = (Serializable) set.getObject(this.getSQLColumn(null, attr.getFieldDefaultName()));
				if (o != null) {
					final Class t = attr.getFieldType();
					if (t == int.class) {
						o = ((Number) o).intValue();
					} else if (t == short.class) {
						o = ((Number) o).shortValue();
					} else if (t == long.class) {
						o = ((Number) o).longValue();
					} else if (t == float.class) {
						o = ((Number) o).floatValue();
					} else if (t == double.class) {
						o = ((Number) o).doubleValue();
					} else if (t == byte.class) {
						o = ((Number) o).byteValue();
					}
				}
				attr.setFieldValue(obj, o);
			}
		}
		return obj;
	}

}
